{{/* Interactive Topological Sort — visually shows rules driving Kahn's algorithm */}}
<div class="interactive-widget" id="topo-widget">
  <div class="widget-body">
    <svg id="topo-svg" viewBox="0 0 560 200" xmlns="http://www.w3.org/2000/svg"></svg>
    <div class="topo-state-bar">
      <div class="topo-state-section">
        <span class="topo-state-label">Queue</span>
        <span class="topo-state-value" id="topo-queue"><em>—</em></span>
      </div>
      <div class="topo-state-section">
        <span class="topo-state-label">Output</span>
        <span class="topo-state-value" id="topo-output"><em>—</em></span>
      </div>
    </div>
    <div class="topo-explain" id="topo-explain"></div>
    <div class="widget-toolbar">
      <div class="widget-toolbar-left">
        <button class="widget-pill topo-ex-btn topo-ex-active" data-ex="0" onclick="topoSetExample(0)">Deferred Shading</button>
        <button class="widget-pill topo-ex-btn" data-ex="1" onclick="topoSetExample(1)">Shadow Cascades</button>
        <button class="widget-pill topo-ex-btn" data-ex="2" onclick="topoSetExample(2)">Post-Processing</button>
      </div>
      <div class="widget-toolbar-right">
        <button class="widget-pill" onclick="topoReset()">Reset</button>
        <button class="widget-btn widget-btn-primary" id="topo-next" onclick="topoNext()">Next ▶</button>
      </div>
    </div>
  </div>
</div>

<style>
.topo-state-bar{display:flex;gap:.75em;flex-wrap:wrap;font-family:ui-monospace,monospace;font-size:.78em;margin-top:.3em}
.topo-state-section{display:flex;align-items:baseline;gap:.4em}
.topo-state-label{font-weight:700;opacity:.5;text-transform:uppercase;font-size:.8em;letter-spacing:.05em}
.topo-state-value{font-weight:600}
.topo-explain{font-size:.82em;line-height:1.5;margin:.5em 0;padding:.4em .7em;border-radius:.375rem;background:var(--color-neutral-100,#f5f5f5);min-height:1.5em;opacity:.75}
:is(.dark,.scheme-congo) .topo-explain{background:var(--color-neutral-900)}
#topo-svg{width:100%;max-height:280px;display:block;margin:0 auto}
#topo-svg .node rect{rx:8;ry:8;stroke-width:1.5}
#topo-svg .node text{font:600 12px ui-monospace,SFMono-Regular,monospace;fill:#fff;pointer-events:none;text-anchor:middle;dominant-baseline:central}
#topo-svg .deg-text{font:700 11px ui-monospace,monospace;pointer-events:none;text-anchor:middle;dominant-baseline:central}
#topo-svg .edge path:not(.flow){fill:none;stroke-width:2}
#topo-svg .edge polygon{stroke:none}
@keyframes edgePulse{0%{stroke-width:2;opacity:.6}50%{stroke-width:3;opacity:.8}100%{stroke-width:2;opacity:.3}}
@keyframes badgePulse{0%{r:11}50%{r:13}100%{r:11}}
.topo-ex-active{color:var(--ds-info);border-color:var(--ds-info);font-weight:600}
:is(.dark,.scheme-congo) .topo-ex-active{color:var(--ds-info);border-color:var(--ds-info)}
</style>

<script>
(function(){
var NW=100,NH=34;
var EXAMPLES=[
  {
    name:"Deferred Shading",
    passes:[
      {id:0,name:"Depth",x:30,y:40},
      {id:1,name:"GBuffer",x:175,y:40},
      {id:2,name:"SSAO",x:360,y:40},
      {id:3,name:"Lighting",x:230,y:130},
      {id:4,name:"Tonemap",x:420,y:130}
    ],
    edges:[
      {from:0,to:1,label:"depth"},
      {from:1,to:2,label:"normals"},
      {from:1,to:3,label:"albedo"},
      {from:2,to:3,label:"ssao"},
      {from:3,to:4,label:"hdr"}
    ]
  },
  {
    name:"Shadow Cascades",
    passes:[
      {id:0,name:"Cascade0",x:20,y:30},
      {id:1,name:"Cascade1",x:20,y:100},
      {id:2,name:"Cascade2",x:20,y:170},
      {id:3,name:"GBuffer",x:200,y:100},
      {id:4,name:"Lighting",x:380,y:65},
      {id:5,name:"Tonemap",x:380,y:150}
    ],
    edges:[
      {from:0,to:4,label:"shadow0"},
      {from:1,to:4,label:"shadow1"},
      {from:2,to:4,label:"shadow2"},
      {from:3,to:4,label:"albedo"},
      {from:4,to:5,label:"hdr"}
    ]
  },
  {
    name:"Post-Processing Chain",
    passes:[
      {id:0,name:"Scene",x:30,y:80},
      {id:1,name:"Bloom",x:180,y:30},
      {id:2,name:"DOF",x:180,y:130},
      {id:3,name:"Composite",x:340,y:80},
      {id:4,name:"TAA",x:460,y:80}
    ],
    edges:[
      {from:0,to:1,label:"hdr"},
      {from:0,to:2,label:"hdr+depth"},
      {from:1,to:3,label:"bloom"},
      {from:2,to:3,label:"dof"},
      {from:3,to:4,label:"color"}
    ]
  }
];

var curExampleIdx=0;
var passes,edgeDefs;
var COL={wait:"#6b7280",queued:"var(--ds-warn)",proc:"var(--ds-info)",done:"var(--ds-success)",edge:"var(--ds-info)",edgeDim:"#374151",edgeConsumed:"var(--ds-danger)"};
var inDeg,queue,sorted,step,done,currentPopped,consumedEdges,activeRule,flashEdges;

function loadExample(idx){
  curExampleIdx=idx;
  var ex=EXAMPLES[idx];
  passes=ex.passes.map(function(p){return{id:p.id,name:p.name,x:p.x,y:p.y}});
  edgeDefs=ex.edges.map(function(e){return{from:e.from,to:e.to,label:e.label}});
  document.querySelectorAll('.topo-ex-btn').forEach(function(b){
    b.classList.toggle('topo-ex-active',parseInt(b.dataset.ex)===idx);
  });
  var maxX=Math.max.apply(null,passes.map(function(p){return p.x}))+NW+30;
  var maxY=Math.max.apply(null,passes.map(function(p){return p.y}))+NH+30;
  document.getElementById('topo-svg').setAttribute('viewBox','0 0 '+maxX+' '+maxY);
  init();
}

function cx(p){return p.x+NW/2}function cy(p){return p.y+NH/2}
function edgePath(e){
  var s=passes[e.from],d=passes[e.to],sx=cx(s),sy=cy(s),dx=cx(d),dy=cy(d);
  var ang=Math.atan2(dy-sy,dx-sx);
  var x1=sx+Math.cos(ang)*(NW/2+2),y1=sy+Math.sin(ang)*(NH/2+2);
  var x2=dx-Math.cos(ang)*(NW/2+7),y2=dy-Math.sin(ang)*(NH/2+7);
  var mx=(x1+x2)/2,my=(y1+y2)/2,nx=-(y2-y1)*.12,ny=(x2-x1)*.12;
  return{x1:x1,y1:y1,x2:x2,y2:y2,mx:mx+nx,my:my+ny,d:"M"+x1+","+y1+" Q"+(mx+nx)+","+(my+ny)+" "+x2+","+y2};
}
function arrowPts(x2,y2,mx,my){
  var a=Math.atan2(y2-my,x2-mx),s=8;
  return x2+","+y2+" "+(x2-s*Math.cos(a-.4))+","+(y2-s*Math.sin(a-.4))+" "+(x2-s*Math.cos(a+.4))+","+(y2-s*Math.sin(a+.4));
}

function highlightRule(n){activeRule=n;}

function init(){
  inDeg=passes.map(function(){return 0});
  edgeDefs.forEach(function(e){inDeg[e.to]++});
  queue=[];sorted=[];step=0;done=false;currentPopped=-1;
  consumedEdges={};flashEdges={};
  passes.forEach(function(_,i){if(inDeg[i]===0)queue.push(i)});
  document.getElementById("topo-next").disabled=false;
  highlightRule(1);
  document.getElementById("topo-explain").innerHTML=
    "<strong>Step 1 — Count prerequisites.</strong> Each pass gets a number showing how many passes must finish before it can run. "+
    queue.map(function(i){return "<strong>"+passes[i].name+"</strong>"}).join(" and ")+
    (queue.length===1?" has":"  have")+" zero incoming edges — nothing blocks "+(queue.length===1?"it":"them")+
    ", so "+(queue.length===1?"it goes":"they go")+" straight into the ready queue.";
  render();
}

function nodeColor(id){
  if(id===currentPopped)return COL.proc;
  if(sorted.indexOf(id)!==-1)return COL.done;
  if(queue.indexOf(id)!==-1)return COL.queued;
  return COL.wait;
}

function render(){
  var svg=document.getElementById("topo-svg");
  svg.innerHTML="";
  var NS="http://www.w3.org/2000/svg";

  // Edges
  edgeDefs.forEach(function(e,ei){
    var p=edgePath(e);
    var key=e.from+"-"+e.to;
    var g=document.createElementNS(NS,"g");g.setAttribute("class","edge");
    var isConsumed=!!consumedEdges[key];
    var isFlashing=!!flashEdges[key];

    var path=document.createElementNS(NS,"path");
    path.setAttribute("d",p.d);
    if(isFlashing){
      path.setAttribute("stroke",COL.edgeConsumed);
      path.setAttribute("stroke-width","3");
      path.setAttribute("opacity","1");
      path.style.animation="edgePulse .5s ease-out";
    }else if(isConsumed){
      path.setAttribute("stroke",COL.edgeDim);
      path.setAttribute("opacity","0.15");
      path.setAttribute("stroke-dasharray","4,3");
    }else{
      path.setAttribute("stroke",COL.edge);
      path.setAttribute("opacity","0.6");
    }
    // Flowing charge overlay for active edges
    if(!isConsumed&&!isFlashing){
      var flow=document.createElementNS(NS,"path");
      flow.setAttribute("d",p.d);flow.setAttribute("class","flow flow-lg");
      g.append(flow);
    }
    var arr=document.createElementNS(NS,"polygon");
    arr.setAttribute("points",arrowPts(p.x2,p.y2,p.mx,p.my));
    arr.setAttribute("fill",isFlashing?COL.edgeConsumed:isConsumed?COL.edgeDim:COL.edge);
    arr.setAttribute("opacity",isConsumed&&!isFlashing?"0.15":"0.6");

    // Label
    var lbl=document.createElementNS(NS,"text");
    lbl.setAttribute("x",p.mx);lbl.setAttribute("y",p.my-8);
    lbl.setAttribute("text-anchor","middle");
    lbl.setAttribute("fill",isConsumed?COL.edgeDim:COL.edge);
    lbl.setAttribute("opacity",isConsumed&&!isFlashing?"0.2":"0.7");
    lbl.style.font="500 10px system-ui,sans-serif";
    if(isConsumed&&!isFlashing)lbl.setAttribute("text-decoration","line-through");
    lbl.textContent=e.label;

    g.append(path,arr,lbl);svg.append(g);
  });

  // Nodes
  passes.forEach(function(p){
    var col=nodeColor(p.id);
    var g=document.createElementNS(NS,"g");g.setAttribute("class","node");
    var r=document.createElementNS(NS,"rect");
    r.setAttribute("x",p.x);r.setAttribute("y",p.y);
    r.setAttribute("width",NW);r.setAttribute("height",NH);
    r.setAttribute("fill",col);
    r.setAttribute("stroke",col===COL.wait?"#4b5563":col===COL.queued?"var(--ds-warn-dark)":col===COL.proc?"var(--ds-info-dark)":"var(--ds-success-dark)");
    var t=document.createElementNS(NS,"text");
    t.setAttribute("x",cx(p));t.setAttribute("y",cy(p));
    t.textContent=p.name;
    g.append(r,t);

    // Badge or checkmark
    if(sorted.indexOf(p.id)===-1&&currentPopped!==p.id){
      var bx=p.x+NW-4,by=p.y-4;
      var bgC=document.createElementNS(NS,"circle");
      bgC.setAttribute("cx",bx);bgC.setAttribute("cy",by);bgC.setAttribute("r","11");
      bgC.setAttribute("fill",inDeg[p.id]===0?"var(--ds-warn)":"var(--ds-danger)");
      bgC.setAttribute("stroke","#fff");bgC.setAttribute("stroke-width","1.5");
      var dt=document.createElementNS(NS,"text");
      dt.setAttribute("class","deg-text");
      dt.setAttribute("x",bx);dt.setAttribute("y",by);
      dt.setAttribute("fill","#fff");
      dt.textContent=inDeg[p.id];
      g.append(bgC,dt);
    }else{
      var ck=document.createElementNS(NS,"text");
      ck.setAttribute("x",p.x+NW-4);ck.setAttribute("y",p.y-2);
      ck.setAttribute("text-anchor","middle");ck.setAttribute("fill","var(--ds-success)");
      ck.style.font="bold 14px sans-serif";ck.textContent="\u2713";
      g.append(ck);
    }
    svg.append(g);
  });

  // Update state bar
  document.getElementById("topo-queue").innerHTML=
    queue.length?queue.map(function(i){return '<span style="color:var(--ds-warn);font-weight:700">'+passes[i].name+'</span>'}).join(", "):"<em>(empty)</em>";
  document.getElementById("topo-output").innerHTML=
    sorted.length?sorted.map(function(i){return '<span style="color:var(--ds-success);font-weight:700">'+passes[i].name+'</span>'}).join(" \u2192 "):"<em>(empty)</em>";
}

window.topoNext=function(){
  if(done)return;
  if(queue.length===0){
    done=true;
    document.getElementById("topo-next").disabled=true;
    highlightRule(5);
    if(sorted.length===passes.length){
      document.getElementById("topo-explain").innerHTML=
        "<strong>All done!</strong> Every pass made it to the output: "+
        sorted.map(function(i){return passes[i].name}).join(" → ")+
        ". The queue drained completely, which means there were no circular dependencies — the graph is valid and this execution order respects every edge.";
    }else{
      document.getElementById("topo-explain").innerHTML=
        "<strong>Problem — cycle detected.</strong> Only "+sorted.length+" of "+passes.length+
        " passes could be sorted. The remaining passes depend on each other in a loop, so none of them can ever reach zero prerequisites. The graph is invalid.";
    }
    currentPopped=-1;render();return;
  }

  // Step: Pop + Consume + Check (rules 2-4 in one click, highlighting each)
  var cur=queue.shift();
  currentPopped=cur;
  step++;

  // Find outgoing edges
  var outEdges=edgeDefs.filter(function(e){return e.from===cur});
  var decremented=[];var newlyQueued=[];

  // Flash the edges being consumed
  flashEdges={};
  outEdges.forEach(function(e){
    var key=e.from+"-"+e.to;
    flashEdges[key]=true;
    consumedEdges[key]=true;
    inDeg[e.to]--;
    decremented.push({name:passes[e.to].name,deg:inDeg[e.to],id:e.to});
    if(inDeg[e.to]===0){queue.push(e.to);newlyQueued.push(passes[e.to].name)}
  });

  sorted.push(cur);

  // Build educational explanation for this step
  var html="<strong>Step "+(step+1)+" — Pick "+passes[cur].name+" from the queue.</strong> ";
  html+="Its prerequisite count was zero, so all passes it depends on have already finished. We add it to the output list.";

  if(outEdges.length>0){
    html+="<br><strong>Update counts:</strong> "+passes[cur].name+" feeds into ";
    html+=outEdges.map(function(e){return passes[e.to].name}).join(", ")+". ";
    html+="We subtract 1 from each of their prerequisite counts";
    if(decremented.length>0){
      html+=" ("+decremented.map(function(d){return d.name+": now "+d.deg}).join(", ")+")";
    }
    html+=".";
    if(newlyQueued.length>0){
      html+=" <strong>"+newlyQueued.join(" and ")+"</strong> "+(newlyQueued.length===1?"drops":"drop")+
        " to zero — "+(newlyQueued.length===1?"it's":"they're")+" unblocked and "+(newlyQueued.length===1?"enters":"enter")+" the ready queue.";
    }
  }else{
    html+="<br>"+passes[cur].name+" has no outgoing edges — no other pass was waiting on it, so no counts change.";
  }

  highlightRule(2);
  document.getElementById("topo-explain").innerHTML=html;

  // Check if done
  if(queue.length===0&&sorted.length===passes.length){
    done=true;
    html+="<br><strong>Queue is empty and all "+passes.length+" passes are in the output — sorting complete!</strong> Final order: "+
      sorted.map(function(i){return passes[i].name}).join(" → ")+".";
    document.getElementById("topo-next").disabled=true;
    document.getElementById("topo-explain").innerHTML=html;
    highlightRule(5);
  }

  render();
  // Clear flash after animation
  setTimeout(function(){flashEdges={};currentPopped=-1;render()},550);
};

window.topoReset=init;
window.topoSetExample=loadExample;

/* ── Lazy-init: defer until widget scrolls into view ── */
var _topoEl=document.getElementById('topo-widget');
var _topoObs=new IntersectionObserver(function(entries){
  if(entries[0].isIntersecting){_topoObs.disconnect();loadExample(0);}
},{rootMargin:'200px'});
_topoObs.observe(_topoEl);
})();
</script>
